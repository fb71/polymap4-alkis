/* 
 * polymap.org
 * Copyright (C) 2015 Polymap GmbH. All rights reserved.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 3.0 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 */
package org.polymap.alkis.model;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Supplier;

import java.sql.Connection;
import java.sql.SQLException;

import org.geotools.data.DataStore;
import org.geotools.data.DataStoreFinder;
import org.geotools.factory.CommonFactoryFinder;
import org.geotools.jdbc.AutoGeneratedPrimaryKeyColumn;
import org.geotools.jdbc.JDBCDataStore;
import org.geotools.jdbc.PrimaryKey;
import org.geotools.jdbc.PrimaryKeyFinder;
import org.opengis.feature.simple.SimpleFeature;
import org.opengis.filter.FilterFactory;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.lucene.search.BooleanQuery;

import org.polymap.core.runtime.LockedLazyInit;

import org.polymap.rhei.fulltext.FullQueryProposalDecorator;
import org.polymap.rhei.fulltext.FullTextIndex;
import org.polymap.rhei.fulltext.indexing.LowerCaseTokenFilter;
import org.polymap.rhei.fulltext.store.lucene.LuceneFullTextIndex;

import org.polymap.model2.Composite;
import org.polymap.model2.query.ResultSet;
import org.polymap.model2.runtime.CompositeInfo;
import org.polymap.model2.runtime.EntityRepository;
import org.polymap.model2.runtime.UnitOfWork;
import org.polymap.model2.store.OptimisticLocking;
import org.polymap.model2.store.geotools.FeatureStoreAdapter;

/**
 * 
 *
 * @author <a href="http://www.polymap.de">Falko Bräutigam</a>
 */
public class AlkisRepository {

    private static Log log = LogFactory.getLog( AlkisRepository.class );
    
    public static final String              DB_NAME = "WBV";
    
    public static final FilterFactory       ff = CommonFactoryFinder.getFilterFactory( null );
    
    /**
     * The global instance, lazily initialized.
     */
    public static final Supplier<AlkisRepository> instance = new LockedLazyInit( () -> new AlkisRepository() );
    
    
    // instance *******************************************

    private EntityRepository                repo;

    private LuceneFullTextIndex             fulltextIndex;

    private DataStore                       ds;
    
    
    /**
     * Configure and initializing the one and only global instance.
     */
    private AlkisRepository() {
        try {
            log.info( "Assembling repository..." );
            
//            Logging.GEOTOOLS.setLoggerFactory( "org.geotools.util.logging.CommonsLoggerFactory" );
            
            //
            BooleanQuery.setMaxClauseCount( 4 * 1024 );
            log.info( "Maximale Anzahl Lucene-Klauseln erhöht auf: " + BooleanQuery.getMaxClauseCount() );
            
//            // init fulltext
//            File dataDir = new File( Polymap.getDataDir(), AlkisPlugin.ID );
//            fulltextIndex = new LuceneFullTextIndex( new File( dataDir, "fulltext" ) );
//            fulltextIndex.addTokenFilter( new LowerCaseTokenFilter() );
            
//            WaldbesitzerFulltextTransformer wbTransformer = new WaldbesitzerFulltextTransformer();
//            wbTransformer.setHonorQueryableAnnotation( true );

            // store
            Map<String,Object> params = new HashMap<String,Object>();
            params.put( "dbtype", "postgis");
            params.put( "host", "localhost");
            params.put( "port", 5432);
            params.put( "schema", "public");
            params.put( "database", "ALKIS");
            params.put( "user", "postgres");
            params.put( "passwd", "postgres");
            ds = DataStoreFinder.getDataStore( params );

            // primary key: gml_id
            ((JDBCDataStore)ds).setPrimaryKeyFinder( new PrimaryKeyFinder() {
                @Override
                public PrimaryKey getPrimaryKey( JDBCDataStore store, String schema, String table, Connection cx ) throws SQLException {
                    AutoGeneratedPrimaryKeyColumn col = new AutoGeneratedPrimaryKeyColumn( "gml_id", String.class );
                    return new PrimaryKey( table, Collections.singletonList( col ) );
                }
            });

            FeatureStoreAdapter store = new FeatureStoreAdapter( ds )
                    .createOrUpdateSchemas.put( false );
            
            // repo
            repo = EntityRepository.newConfiguration()
                    .entities.set( new Class[] {
                            AX_Flurstueck.class, 
                            AX_Buchungsstelle.class,
                            AX_Person.class} )
                    .store.set( 
                            new OptimisticLocking(
                            //new FulltextIndexer( fulltextIndex, new TypeFilter( Waldbesitzer.class ), newArrayList( wbTransformer ),
                            store ) ) //)
                    .create();
        }
        catch (RuntimeException e) {
            throw e;
        }
        catch (Exception e) {
            throw new RuntimeException( e );
        }
    }
    
    
    public EntityRepository repo() {
        return repo;
    }

    
    public FullTextIndex fulltextIndex() {
        return new FullQueryProposalDecorator(
               new LowerCaseTokenFilter( fulltextIndex ) );

    }


    public <T extends Composite> CompositeInfo<T> infoOf( Class<T> compositeClass ) {
        return repo.infoOf( compositeClass );
    }


    public UnitOfWork newUnitOfWork() {
        return repo.newUnitOfWork();
    }

    
    /**
     * Simple access test.
     */
    public static void main( String[] args ) throws Exception {
        AlkisRepository r = new AlkisRepository();
        
        // type names
        String[] typeNames = r.ds.getTypeNames();
        System.out.println( "TypeNames:" + Arrays.asList( typeNames ) );
        
        System.out.println( "== " + r.ds.getSchema( AX_Flurstueck.TYPE.info().getNameInStore() ) );
        
        //
        UnitOfWork uow = r.newUnitOfWork();
        ResultSet<AX_Flurstueck> rs = uow.query( AX_Flurstueck.class ).maxResults( 3 ).execute();
        for (AX_Flurstueck fst : rs) {
            SimpleFeature feature = (SimpleFeature)fst.state();
            System.out.println( "== " + fst );

            System.out.println( "primary key: " + feature.getID() );
            feature.getProperties().stream().forEach( p -> System.out.println( "  " + p.getName() + " = " + p.getValue() ) );
            
            System.out.println( "id: " + fst.id() );            
            System.out.println( "zaehler: " + fst.zaehler.get() /*+ " - " + fst.flurstuecksnummer.get().zaehler.get()*/ );            
            System.out.println( "nenner: " + fst.nenner.get() );            
            System.out.println( "flurnummer: " + fst.flurnummer.get() );            
            System.out.println( "istGebucht: " + fst.istGebucht.get() );            
            System.out.println( "buchungsstelle: " + fst.buchungsstelle() );            
            System.out.println( "    laufende: " + fst.buchungsstelle().laufendeNummer.get() );            
        }
        
        // id query
        AX_Flurstueck fst = uow.entity( AX_Flurstueck.class, "DESTLIKA00028CfI" );
        System.out.println( "-> " + fst );
        
        uow.query( AX_Person.class ).maxResults( 3 ).execute().spliterator().forEachRemaining( person -> {
            SimpleFeature feature = (SimpleFeature)person.state();
            System.out.println( "primary key: " + feature.getID() );
            feature.getProperties().stream().forEach( p -> System.out.println( "  " + p.getName() + " = " + p.getValue() ) );
        });

    }
    
}
